Каким будет результат выполнения программы?
class A { 
    static byte m1() { 
      final char c1 = '\u0001'; 
      return c1;                                  // 1 
    } 
    static byte m2(final char c2) { return c2; }  // 2 
    public static void main(String[] args) { 
        char c3 = '\u0003';  
        System.out.print("" + m1() + m2(c3));         // 3 
    } 
} 
Пояснение: Ошибка компиляции в строке 2 возникает из-за невозможности выполнить неявное преобразования типа выражения
в return (char) к типу, указанному в заголовке метода (byte).
Ошибки можно избежать, если выполнить явное преобразование типа: "return (byte) c2;"
В похожей ситуации в строке 1 ошибка компиляции не возникает, потому что c1 - это константа и,
фактически, компилятор имеет дело с выражением "return 1" - а это значение попадает в диапазон byte.
--------------------------------------------------------------------------------------------------------------------
import java.util.TreeSet; 
 
public class TestTreeSet { 
 
    public static void main(String[] args) { 
        TreeSet<Item> set = new TreeSet<Item>(); 
        set.add(new Item(2)); 
        set.add(new Item(5)); 
        set.add(new Item(2)); 
        System.out.println(set); 
    } 
 
    static class Item { 
        int n; 
        Item(int n) { 
            this.n = n; 
        } 
        public String toString() { 
            return "Item " + n; 
        } 
    } 
} 
Пояснение: Будет выброшен ClassCastException, т.к. в TreeSet для упорядочивания элементов используется метод compareTo(или compare),
соответственно, в нем могут храниться объекты,
реализующие интерфейс Comparable, либо необходимо передавать свою реализацию Comparator-а в конструкторе.
-------------------------------------------------------------------------------------------------------------------------------
Пояснение: В case-секциях оператора switch можно использовать переменные, если они объявлены как final.
Это условие не выполняется в случае переменных, для которых нужен autounboxing.
----------------------------------------------------------------------------------------------
class A { 
    int i = 0; 
    public int increment() { 
        return ++i; 
    } 
} 
  
public class B extends A { 
    int i = 10; 
    public int increment() { 
        return ++i; 
    } 
  
    public static void main(String[] args) { 
        A obj = (A) new B();  
        System.out.println(obj.increment()); 
    } 
} 

Пояснение: Метод A.increment() перекрывается в классе B.
Поэтому, вне зависимости от типа переменной obj, будет вызываться метод, соответствующий реальному типу объекта - т.е. B.increment().
Этот метод будет использовать переменную i, объявленную в том же классе B и имеющую начальное значение 10.
Результирующее значение - 11.
----------------------------------------------------------------------------------------------------
